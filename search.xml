<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>以梦为马，不负韶华</title>
    <url>/2020/05/20/benxi/</url>
    <content><![CDATA[<hr>
<blockquote class="blockquote-center">如果你真的愿意去努力，你人生最坏的结果，也不过是大器晚成。</blockquote>
 ​​​]]></content>
      <categories>
        <category>全世界最好的苏潼</category>
      </categories>
      <tags>
        <tag>ytt</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动方法总结</title>
    <url>/2020/12/13/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>清除浮动方法总结</p>
<a id="more"></a>
<h4 id="为什么要清除浮动？"><a href="#为什么要清除浮动？" class="headerlink" title="为什么要清除浮动？"></a>为什么要清除浮动？</h4><p>我们很多时候不方便给父盒子的高度，因为我们不清除有多少子盒子，有多少内容。经常的做法会让内容撑开父盒子的高度。<br>但是如果父盒子中有子盒子浮动了之后，就会影响到后面的盒子，因为浮动元素脱离了标准流。会把后面还在标准流的盒子覆盖，解决这个问题的方法就要清除浮动。</p>
<blockquote>
<p><strong>清除浮动的本质：</strong> 为解决父级元素因为子级浮动引起高度为0的问题</p>
</blockquote>
<h4 id="如何清除浮动？"><a href="#如何清除浮动？" class="headerlink" title="如何清除浮动？"></a>如何清除浮动？</h4><p> 清除浮动其实叫做 闭合浮动 更合适，因为是把浮动的元素圈起来，让父元素闭合出口和入口不让他们出来影响其他的元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  选择器 &#123; clear : 属性值 ; &#125;</span><br><span class="line">&#x2F;*属性值为left,清除左侧浮动的影响</span><br><span class="line">  属性值为right,清除右侧浮动的影响</span><br><span class="line">  属性值为both,同时清除左右两侧浮动的影响*&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h5><h6 id="末尾标签法"><a href="#末尾标签法" class="headerlink" title="末尾标签法"></a>末尾标签法</h6><p> 通过在浮动元素的末尾添加一个空的标签。这是W3C推荐的做法，虽然比较简单，但是添加了无意义的标签，结构化比较差，所以不推荐使用。下面三种写法都适用：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--写法一：直接用style--&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;clear:both&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--写法二：使用clear类--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.clear &#123; clear:both &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--写法三：可以使用br等别的块级元素来清除浮动--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.clear &#123; clear:both &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;br class&#x3D;&quot;clear&quot; &#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h6 id="内部标签法"><a href="#内部标签法" class="headerlink" title="内部标签法"></a>内部标签法</h6><p> 把div放进父盒子里，这样盒子会撑开，一般也不会用。</p>
<h5 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h5><p> 给父级元素添加overflow样式方法。</p>
<p>这种方法代码比较简洁，可以通过触发BFC方式，但是因为本身overflow的本质是 溢出隐藏 的效果，所以有的时候也会有一些问题存在，比如内容增多的时候不会自动换行导致内容被隐藏掉，无法显示出要溢出的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">    overflow: auto;  </span><br><span class="line">  &#x2F;* 加上这句话，就可以清除浮动   overflow &#x3D; hidden|auto|scroll 都可以实现*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="伪元素法（最常用）"><a href="#伪元素法（最常用）" class="headerlink" title="伪元素法（最常用）"></a>伪元素法（最常用）</h5><h6 id="使用after伪元素清除浮动"><a href="#使用after伪元素清除浮动" class="headerlink" title="使用after伪元素清除浮动"></a>使用after伪元素清除浮动</h6><p>after是在父元素中加一个盒子，这个元素是通过css添加上去的，符合闭合浮动思想，结构语义化正确。 父元素中加一个类名为clearfix 。但是这个方法IE6-IE7不识别，要进行兼容，使用zoom:1触发hasLayout来清除浮动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:&quot;.&quot;;  &#x2F;*尽量不要为空，一般写一个点*&#x2F;</span><br><span class="line">    height:0;     &#x2F;*盒子高度为0，看不见*&#x2F;</span><br><span class="line">    display:block;    &#x2F;*插入伪元素是行内元素，要转化为块级元素*&#x2F;</span><br><span class="line">    visibility:hidden;      &#x2F;*content有内容，将元素隐藏*&#x2F;</span><br><span class="line">    clear:both;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;   &#x2F;*  *只有IE6,7识别 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="after伪元素空余字符法"><a href="#after伪元素空余字符法" class="headerlink" title="after伪元素空余字符法"></a>after伪元素空余字符法</h6><p>父元素中加一个类名为clearfix，也需要兼容IE6-IE7</p>
<blockquote>
<p>在Unicode字符里有一个“零宽度空格”，即U+200B，代替“.”，可以减少代码量，不再使用visibility:hidden</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">    content:&quot;\200B&quot;;   &#x2F;* content:&#39;\0200&#39;; 也可以 *&#x2F;</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="使用before和after双伪元素清除浮动（推荐）"><a href="#使用before和after双伪元素清除浮动（推荐）" class="headerlink" title="使用before和after双伪元素清除浮动（推荐）"></a>使用before和after双伪元素清除浮动（推荐）</h6><p>这种方法完全符合闭合浮动思想。给父元素加一个类名为clearfix,需要兼容IE6-IE7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after &#123;</span><br><span class="line">     content: &quot;&quot;; </span><br><span class="line">     display: table;</span><br><span class="line"> &#125;</span><br><span class="line"> .clearfix:after &#123;</span><br><span class="line">     clear: both;</span><br><span class="line"> &#125;</span><br><span class="line"> .clearfix &#123;</span><br><span class="line">     *zoom: 1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2020/12/13/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<hr>
<p>整理了一遍css选择器</p>
<a id="more"></a>

<h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h4><p>以#加id名来表示, id是唯一的，同一个页面里不允许多个ID相同的元素。一般只用来强调某个页面或者某个模块，多个功能相同的模块建议使用类选择器。</p>
<h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>以.加上class名称来表示。</p>
<h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>直接标签名作为选择器的名称，如果使用标签选择器，那么该页面所有使用该标签的元素样式都会改变，一般不建议使用。</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul>
<li>[attr]表示选择所有带有attr属性的标签</li>
<li>[attr=xxx]表示用来选择有attr属性且属性值等于xxx的元素，注意属性值必须完全相等</li>
<li>[attr|=xxx] 表示选择属性值为xxx（这里必须是相等的）或者 以xxx-属性开头的元素</li>
<li>[attr^=xxx]表示选择以xxx属性开头的元素</li>
<li>[attr$=xxx]表示选择以xxx属性结尾的元素</li>
<li>[attr*=xxx]表示选择属性值中包含xxx的所有元素</li>
</ul>
<h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><p>通配符顾名思义，就是所有标签全部适用，把样式应用到所有元素上影响浏览器渲染效率，实际开发中不建议使用。</p>
<h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h4><p>又称派生选择器，派生选择器为css2的说法。 以seletorA空格selectorB形式，表示在selectorA内部向下查找所有所有符合selectorB的元素，无论层级有多深依然会被作用。<br>后代选择器可以叠加使用，注意的是：CSS选择器是从右到左进行匹配的，嵌套的层级越深，css选择器查找的效率就越低，以及权重就过低可能会被其他的样式所覆盖。</p>
<h5 id="css权重表："><a href="#css权重表：" class="headerlink" title="css权重表："></a>css权重表：</h5><table>
<thead>
<tr>
<th>选择器</th>
<th align="center">用法</th>
<th align="center">权重值</th>
</tr>
</thead>
<tbody><tr>
<td>!importan</td>
<td align="center">放在属性值后， 如color: red !important;</td>
<td align="center">10000</td>
</tr>
<tr>
<td>内联样式</td>
<td align="center">style=”xxx”</td>
<td align="center">1000</td>
</tr>
<tr>
<td>ID选择器</td>
<td align="center">#box</td>
<td align="center">100</td>
</tr>
<tr>
<td>类、伪类、属性选择器</td>
<td align="center">.box、:hover、div[class=box]</td>
<td align="center">10</td>
</tr>
<tr>
<td>标签选择器和伪元素选择器</td>
<td align="center">p、:before</td>
<td align="center">1</td>
</tr>
<tr>
<td>通配符* 子选择器&gt; 相邻选择器+ 同胞选择器~</td>
<td align="center">略</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><p>以selectorA&gt;selectorB的形式，表示只查找指定元素的直接子元素，层级为一层。</p>
<h4 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h4><p>以selectorA+selectorB的形式，表示选择紧接在指定元素后的元素，且二者有相同父元素。注意他只有一个兄弟。</p>
<h4 id="同胞选择器"><a href="#同胞选择器" class="headerlink" title="同胞选择器"></a>同胞选择器</h4><p>以selectorA~selectorB形式，表示选择指定元素所有符合条件的所有兄弟元素， 他可能有多个兄弟。</p>
<h4 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h4><p>以selectorA.selectorB形式，表示既符合选择器A又符合选择器B的元素</p>
<h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h4><p>以seltorA,selectorB逗号分隔的形式，表示不同的选择器A和选择器B的元素都应用同一种样式。</p>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>以selector加:的的形式，CSS 伪类用于向某些选择器添加特殊的效果，这里只列举常见的几种：</p>
<ul>
<li>表示状态：</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th align="center">作用</th>
<th align="center">栗子</th>
</tr>
</thead>
<tbody><tr>
<td>x:link</td>
<td align="center">未访问的链接</td>
<td align="center">a:link</td>
</tr>
<tr>
<td>x:visited</td>
<td align="center">已访问的链接</td>
<td align="center">a:visited</td>
</tr>
<tr>
<td>x:hover</td>
<td align="center">鼠标移动到链接上</td>
<td align="center">a:hover</td>
</tr>
<tr>
<td>x:active</td>
<td align="center">选定的链接</td>
<td align="center">a:acitve</td>
</tr>
<tr>
<td>x:focus</td>
<td align="center">选定元素聚焦时的样式</td>
<td align="center">input:focus</td>
</tr>
</tbody></table>
<ul>
<li>表示结构:</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th align="center">作用</th>
<th align="center">栗子</th>
</tr>
</thead>
<tbody><tr>
<td>x:first-child</td>
<td align="center">第一个子元素为x</td>
<td align="center">ul li:first-child</td>
</tr>
<tr>
<td>x:last-child</td>
<td align="center">最后一个子元素为x</td>
<td align="center">ul li:last-child</td>
</tr>
<tr>
<td>x:nth-child(n)</td>
<td align="center">第n个位置的子元素x，不分元素类型</td>
<td align="center">ul li:nth-child(even)</td>
</tr>
<tr>
<td>x:nth-last-child(n)</td>
<td align="center">同上，倒数第n个位置的子元素x</td>
<td align="center">ul li:nth-last-child(2)</td>
</tr>
<tr>
<td>x:only-child</td>
<td align="center">唯一子元素为x</td>
<td align="center">a span:only-child</td>
</tr>
<tr>
<td>x:only-of-type</td>
<td align="center">唯一子元素为x, 且x没有其他同类型的兄弟元素</td>
<td align="center">a span:only-of-type</td>
</tr>
</tbody></table>
<h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>CSS 伪元素用于将特殊的效果添加到某些选择器，主要介绍两种比较常见的。</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th align="center">作用</th>
<th align="center">栗子</th>
</tr>
</thead>
<tbody><tr>
<td>x::after</td>
<td align="center">在元素x的内容前面插入新内容</td>
<td align="center">a::after</td>
</tr>
<tr>
<td>x::before</td>
<td align="center">在元素x的内容后面插入新内容</td>
<td align="center">a::before</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>越努力越幸运</title>
    <url>/2020/12/13/bad/</url>
    <content><![CDATA[<hr>
<blockquote class="blockquote-center">人的一切痛苦本质上都是对自己无能的愤怒</blockquote>
 ​​​]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>越努力越幸运</tag>
      </tags>
  </entry>
  <entry>
    <title>龙三Sakura和绘梨衣</title>
    <url>/2020/12/11/longzu3/</url>
    <content><![CDATA[<p>“世界喜不喜欢你，只取决于你的朋友喜不喜欢你，每个人都有几个真正的好朋友，他们喜欢你，就是这个世界喜欢你了。”</p>
<p>“什么是好朋友？”绘梨衣在小本子上写。</p>
<p>“就是那种很神经病的朋友，不管怎么样都会相信你，不管怎么样都会跟你在一起，”说到这里的时候忽然有种巨大的悲伤和强烈的酸楚充斥着他的鼻腔，路明非不知道那种情绪从何而来，只觉得自己要被那冰冷的、浩荡的悲伤淹没，他说：“如果世界真的不喜欢你，那世界就是我的敌人了。”</p>
]]></content>
      <categories>
        <category>幻想文学</category>
      </categories>
  </entry>
</search>
